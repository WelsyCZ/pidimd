<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const editor = document.querySelector("#editor");
const preview = document.querySelector("#preview-section");
const sidebar = document.querySelector("#sidebar");
const nav = document.querySelector("#nav");
const main = document.querySelector("#main");
let mdflist;

// PARSER ------------------------
// regex rules paired with html which will replace the match
const headlineRules = [
    [/^#{3}\s+(.+)$/gm, "&lt;h3>$1&lt;/h3>"],     //h3
    [/^#{2}\s+(.+)$/gm, "&lt;h2>$1&lt;/h2>"],     //h2
    [/^#{1}\s+(.+)$/gm, "&lt;h1>$1&lt;/h1>&lt;hr>"]  //h1
];

const bisRules = [
    [/(?&lt;!\\)\*\*([^\n]*?[^\n\\])\*\*/g, "&lt;b>$1&lt;/b>"], // **bold**
    [/(?&lt;!\\)\*([^\n]*?[^\n\\])\*/g, "&lt;i>$1&lt;/i>"], // *italic*
    [/(\s)__([^_\n]*?[^\n\\])__(\s)/g, "&lt;b>$1$2$3&lt;/b>"], // __bold__
    [/(\s)_([^_\n]*?[^\n\\])_(\s)/g, "&lt;i>$1$2$3&lt;/i>"], // _italic_
    [/(?&lt;!\\)~~([^\n]*?[^\n\\])~~/g, "&lt;s>$1&lt;/s>"] // ~~strikthrough~~
];

const escapeRules = [
    [/\\\*/g, "*"], // escape * 
    [/\\\_/g, "_"], // escape _
    [/\\\~/g, "~"]  // escape ~
];
// newline if end lines with 2 spaces or a backslash
const linebreakRule = [/(?:  |\\)$/gm, "&lt;br>"];
// a paragraph is a line of text followed by 0 or more nonempty lines
const paragraphRule = [/^([A-Za-z].*(?:\n[A-Za-z].*)*)/gm, "&lt;p>$1&lt;/p>"];
// URL or link validity is not checked, we only care about syntax
const linkRule = [/(?&lt;!!)\[([^\n]+?)\]\(([^\n]+)\)/g,"&lt;a href='$2'>$1&lt;/a>"];
const imgRule = [/!\[([^\n]+?)\]\(([^\n]+)\)/g, "&lt;img src='$2' title='$1' style='max-width: 80%' />"];

/**
 * Parses markdown into HTML
 * 
 * @param {string} text - Text containing markdown we intend to parse
 * @returns {string} - HTML containing parsed text
 */
function parseMD(text){
    // headlines
    for(const [rule,template] of headlineRules){
        text = text.replace(rule, template);
    }
    
    // bold, italics
    for(const [rule,template] of bisRules){
        text = text.replace(rule, template);
    }
    
    // paragraph and linebreak
    text = text.replace(linebreakRule[0], linebreakRule[1]);
    text = text.replace(paragraphRule[0], paragraphRule[1]);
    
    // link
    text = text.replace(linkRule[0], linkRule[1]);

    // Image
    text = text.replace(imgRule[0], imgRule[1]);
    

    // remove backslashes for escaped characters
    for(const [rule,template] of escapeRules){
        text = text.replace(rule, template);
    }
    return text;
}

// PARSER END --------------------

/**
 * Renders the preview area
 * 
 * @param {string=} text - Optional argument, the text to be parsed
 * into html, if not specified, the editor content will be used
 */
function render(text = null){
    if(!text) text = $("#editor").val();
    let parsed = parseMD(text);
    preview.innerHTML = parsed;
    mdflist.saveFile();
}

/**
 * Wraps the selected text inside #editor textarea with given
 * prefix and suffix. In case of no selection, cursor position
 * is wrapped instead
 * 
 * @param {string} pref - prefix to go in front of selected text
 * @param {*} suff - suffix to go after the selected text
 */
function wrapSelection(pref, suff){
    let txt = $("#editor")[0];
    const bef = txt.value.substring(0,txt.selectionStart);
    const sel = txt.value.substring(txt.selectionStart, txt.selectionEnd);
    const aft = txt.value.substring(txt.selectionEnd);
    txt.value = `${bef}${pref}${sel}${suff}${aft}`;
}
const buttons = document.getElementsByTagName("button");
/**
 * Array of pairs [prefix,suffix] for toolbar buttons (in their order)
 * 
 * @type {string[][]}
 */
const wrappers = [
    ["**","**"],
    ["*","*"],
    ["~~","~~"],
    ["# ",""],
    ["## ",""],
    ["### ",""],
    ["[Enter Caption Here](",")"],
    ["![Enter Hover Text Here](",")"]
];

/** Class representing a markdown file */
class Filedotmd {
    /**
     * Create a new markdown file
     * @param {string} name - name of the markdown file 
     * @param {string} content - the literal text contents of the file
     * @param {boolean} open - status variable indicating if its open 
     */
    constructor(name, content, open=false){
        this.name = name;
        this.content = content;
        this.open = open;
    }
    /**
     * name getter
     * @returns file name
     */
    getName = () => {
        return this.name;
    }
    /**
     * getter for markdown content
     * @returns file text contents (raw markdown)
     */
    getContent = () => {
        return this.content;
    }
    /**
     * filename setter
     * @param {string} name - new name to be set 
     */
    setName = (name) => {
        this.name = name;
    }
    /**
     * markdown content setter
     * @param {string} content - new markdown content of the file to be set
     */
    setContent = (content) => {
        this.content = content;
    }
    /**
     * Open value setter
     * @param {boolean} open - status value if is open 
     */
    setOpen = (open) => {
        this.open = open;
    }
}
/** Class representing a list of all markdown files */
class Filelist{
    /**
     * Creates a new list of markdown files
     * @param {Array} files - list of cached file objects through localStorage
     */
    constructor(files=null){
        this.filenames = [];
        this.files = []; 
        this.curopen = null;
        if(files){ //import the cached files if provided
            let name,content,open;
            for(let file of files){
                name = file.name;
                content = file.content;
                open = file.open;
                this.newFile(name,content,open);
                if(open) this.curopen = name;
            }
        }
    }
    /**
     * Creates a new Filedotmd object and inserts into the list
     * @param {*} name - name of the new file
     * @param {*} content - content of the new file
     * @param {*} open - open status of the new file
     */
    newFile = (name=null, content=null, open=false) => {
        let nm = name &amp;&amp; this.nameFree(name) ? name : this.getFreeName();
        content = content ? content : `# ${nm}\nContent...`;
        let nfile = new Filedotmd(nm,content,open);
        this.filenames.push(nm);
        this.files.push(nfile);
    }
    /**
     * Checks if a filename is available (they are unique)
     * @param {string} name - desired name
     * @returns {boolean} - true if available, false otherwise
     */
    nameFree = (name) => {
        return !this.filenames.includes(name);
    }
    /**
     * Generates a guaranteed free name for a file
     * @returns generated free name
     */
    getFreeName = () => {
        let name = `file${this.filenames.length+1}`;
        while(this.filenames.includes(name)){
            name = name + "1";
        }
        return name;
    }
    /**
     * filenames getter
     * @returns filenames of all existing files
     */
    getFilenames = () => {
        return this.filenames;
    }
    /**
     * files getter
     * @returns array of all Filedotmd objects
     */
    getFiles = () => {
        return this.files;
    }
    /**
     * Get a file by filename
     * @param {string} filename - name of the wanted file
     * @returns {Filedotmd} - Found file or null if not found
     */
    getFile = (filename) => {
        let index = this.filenames.indexOf(filename);
        return index > -1 ? this.files[index] : null;
    }
    /**
     * Rename an existing file based on filename
     * @param {string} oldname - name of an existing file to be renamed
     * @param {string} newname - the new filename after rename
     * @returns {boolean} - true if rename was successful, false otherwise
     */
    renameFile = (oldname, newname) => {
        let index = this.filenames.indexOf(oldname);
        if(index > -1){
            if(this.nameFree(newname)){
                this.filenames[index] = newname;
                this.files[index].setName(newname);
                this.curopen = newname;
                return true;
            }
        }
        return false;
    }
    /**
     * Opens an existing Filedotmd
     * @param {string} filename - filename of file to be opened
     */
    openFile = (filename) => {
        let file = this.getFile(filename);
        if(file){
            if(this.curopen){
                let opn = this.getFile(this.curopen);
                if(opn) opn.setOpen(false);
            }
            $('#editor').val(file.getContent());
            file.setOpen(true);
            this.curopen = filename;
            render();
        }
    }
    /**
     * Saves any changes made to the file
     */
    saveFile = () => {
        let file = this.getFile(this.curopen);
        if(!file) {
            console.log("no file to save");
            return;
        }
        file.setContent($("#editor").val());
    }
    /**
     * Delete a Filedotmd based on specified filename
     * @param {string} filename 
     */
    deleteFile = (filename) => {
        let index = this.filenames.indexOf(filename);
        if(index > -1){
            this.filenames.splice(index,1);
            this.files.splice(index,1);
            if(this.filenames.length > 0){
                this.openFile(this.filenames[0]);
            } else { // if we deleted the last file, create new example file
                this.newFile("example", welcometext);
                this.openFile("example");
            }
        }
    }

}

/**
 * Function that populates the collapsing sidebar
 * with all the existing Filedotmd buttons
 */
function populateSidebar(){
    nav.innerHTML = "";
    for(let file of mdflist.getFiles()){
        let div = document.createElement("div");
        div.className = "file";
        if(file.open) div.classList.add("open");
        div.innerText = file.getName();
        div.addEventListener("click", (e) => {
            // ignore clicks into the input field
            if(e.target.tagName == "INPUT"){
                return;
            } 
            mdflist.openFile(e.target.innerText);
            populateSidebar();
        });
        nav.appendChild(div);
    }
}

/**
 * Sound that pressing a button makes
 * @type {Audio}
 */
const buttonsound = new Audio("buttonsound.ogg");

// Add click event listener to hamburger button that opens sidebar
buttons[0].addEventListener("click", () => {
    buttonsound.play();
    sidebar.classList.toggle("sbon");
    main.classList.toggle("mainon");
});
// Add click event listeners to all toolbar buttons (bold, italic...)
for(let i = 1; i &lt; 9; ++i){
    const [pref,suff] = wrappers[i-1];
    buttons[i].addEventListener("click", () => {
        buttonsound.play();
        wrapSelection(pref, suff);
        render();
    });
}
// Add click event listener to the plus button (creates new file)
document.getElementById("plus").addEventListener("click", () => {
    buttonsound.play();
    mdflist.newFile();
    let fnames = mdflist.getFilenames();
    mdflist.openFile(fnames[fnames.length-1]);
    populateSidebar();
});
/**
 * Add event listener to the rename button
 * 
 * renaming creates an input text field in place of the file name
 * the rename only goes through if enter is pressed, escape or
 * clicking elsewhere cancels it
 */
document.getElementById("rename").addEventListener("click", () => {
    let open = document.getElementsByClassName("open")[0];
    let oldname = open.innerHTML;
    open.innerHTML = "";
    let inptext = document.createElement("input");
    inptext.type = "text";
    inptext.value = oldname;
    inptext.onkeyup = (e) => {
        if(e.key === "Enter"){
            mdflist.renameFile(oldname,inptext.value);
            populateSidebar();
        }
        if(e.key === "Escape"){
            populateSidebar();
        }
    };
    inptext.addEventListener("focusout", () => {
        populateSidebar();
    });
    open.appendChild(inptext);
    inptext.select();
});
// Add event listener to the delete button, there is a confirmation
document.getElementById("delete").addEventListener("click", () => {
    let name = document.getElementsByClassName("open")[0].innerText;
    let rly = confirm(`Do you really want to delete the current file called '${name}'?`);
    if(rly) {
        mdflist.deleteFile(name);
        populateSidebar();
    }
});
// Add event listener to the help button
document.getElementById("help").addEventListener("click", () => {
    mdflist.newFile("Tutorial", tutorial);
    mdflist.openFile(mdflist.filenames[mdflist.filenames.length-1]);
    populateSidebar();
});

// Render any changes in the editor text area immediately
editor.addEventListener("input", e => {
    let content = e.target.value;
    render(content);
});

// LOCAL STORAGE ---------------


/**
 * Loads cached files from localStorage on page load
 * If no files are cached, a new example file is created instead
 */
window.onload = function() {
    // let cache = sessionStorage.getItem("cachedtext");
    // if(cache){
    //     $('#editor').val(cache);
    // } else {
    //     $('#editor').val(welcometext);
    // }
    // render();
    let files = localStorage.getItem("files");
    if(files){
        mdflist = new Filelist(JSON.parse(files));
        mdflist.openFile(mdflist.curopen);
    } else {
        mdflist = new Filelist();
        mdflist.newFile("example", welcometext);
        mdflist.openFile("example");
    }
    populateSidebar();
}
/**
 * Before closing the page, changes to the file are saved
 * and all files are cached into localStorage
 */
window.onbeforeunload = function() {
    mdflist.saveFile()
    localStorage.setItem("files", JSON.stringify(mdflist.getFiles()));
}
/**
 * Example file template
 * @type {string}
 */
const welcometext = `# Nadpis 1
## Nadpis 2
### Nadpis 3

Tohle je **tuÄnej paragraf**, *kurzÃ­va* a ***tuÄnÃ¡ kurzÃ­va***  
furt ten samej paragraf, ale jinej Å™Ã¡dek


Tohle je uÅ¾ ale jinej paragraf. U**PRO**ST*Å˜E*D

A tady je dalÅ¡Ã­ __tuÄnÃ½__ a _cursive_  text.

Chci napsat \\* a potom zase \\* a tÅ™eba \\_

tuÄnÃ½ hvÄ›zdiÄky ** \\*\\*\\*\\_\\_\\*\\*\\_ ** a podtrÅ¾Ã­tka

jo a tady mÃ¡Å¡ [odkaz](https://cs.wikipedia.org/wiki/Welsh_Corgi_Pembroke) na wiki o Corgim a taky jeho obrÃ¡zek

![corgiiii](https://i.imgur.com/nP3SZ0j.jpg)

Ten je ~~zlej~~ hodnej, co? 

pÅ™eÅ¡krtlÃ¡ ~~\\~~~ vlnovka
`

const tutorial = `# NÃ¡vod
## HornÃ­ liÅ¡ta (toolbar)

PrvnÃ­ (hamburger) tlaÄÃ­tko otevÃ­rÃ¡ postrannÃ­ menu se soubory  
**B** tlaÄÃ­tko - obalÃ­ vybranÃ½ text (nebo kurzor) znaÄkami pro tuÄnÃ½ text  
*I* tlaÄÃ­tko - obalÃ­ vybranÃ½ text (nebo kurzor) znaÄkami pro kurzÃ­vu  
~~S~~ tlaÄÃ­tko - pÅ™eÅ¡krtnutÃ½ text

H1,H2,H3 - vytvoÅ™Ã­ nadpis 1. aÅ¾ 3. ÃºrovnÄ›  
ğŸ”— - vloÅ¾enÃ­ odkazu, formÃ¡t je  [ViditelnÃ½ text] (skuteÄnÃ½ odkaz) bez mezery vprostÅ™ed
IMG - vloÅ¾enÃ­ obrÃ¡zku, formÃ¡t je ![Text pÅ™i najetÃ­ na obrÃ¡zek] (url obrÃ¡zku) bez mezery vprostÅ™ed

## BoÄnÃ­ liÅ¡ta (otevÃ­ranÃ¡ â˜° tlaÄÃ­tkem)

Obsahuje 4 tlaÄÃ­tka - vytvoÅ™enÃ­ souboru, pÅ™ejmenovÃ¡nÃ­ souÄasnÃ©ho souboru, smazÃ¡nÃ­ souÄasnÃ©ho souboru a na **vytvoÅ™enÃ­ tohoto nÃ¡vodnÃ©ho souboru**

DÃ¡le obsahuje seznam vÅ¡ech uloÅ¾enÃ½ch markdown souborÅ¯, mezi kterÃ½mi mÅ¯Å¾eme pÅ™epÃ­nat kliknutÃ­m

Soubory se uklÃ¡dajÃ­ pÅ™i jakÃ©koliv zmÄ›nÄ›

`</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Filedotmd.html">Filedotmd</a></li><li><a href="Filelist.html">Filelist</a></li></ul><h3>Global</h3><ul><li><a href="global.html#buttonsound">buttonsound</a></li><li><a href="global.html#parseMD">parseMD</a></li><li><a href="global.html#populateSidebar">populateSidebar</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#welcometext">welcometext</a></li><li><a href="global.html#wrapSelection">wrapSelection</a></li><li><a href="global.html#wrappers">wrappers</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed Sep 06 2023 23:20:00 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
